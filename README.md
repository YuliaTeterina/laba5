# Тетерина Юлия 7 группа 
# Лабораторная №5
# Вариант №10

# Задание 1  
### Задача 1  
В класс Дробь, добавить интерфейс на два метода: получение вещественного значения, установка 
числителя и установка знаменателя. 
Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного 
значения. 
### Реализация 
1. FractionInterface - интерфейс с методами:
   * getRealValue() - получение вещественного значения
   * setNumerator(int) - установка числителя
   * setDenominator(int) - установка знаменателя
2. Fraction - базовая реализация дроби:
   * Хранит числитель и знаменатель
   * Проверяет, что знаменатель ≠ 0
   * Автоматически нормализует отрицательные знаменатели
   * Имеет корректные equals() и hashCode()
   * getRealValue() вычисляет значение каждый раз
3. CachedFraction - кэшированная версия (наследует Fraction):
   * Добавляет поле cachedValue
   * При первом вызове getRealValue() вычисляет и сохраняет в кэш
   * При последующих вызовах возвращает значение из кэша
   * При изменении числителя/знаменателя сбрасывает кэш
### Алгоритм решения задачи
1. Пользователь вводит числитель и знаменатель
2. Программа создает:
   - Обычную дробь (Fraction)
   - Кэшированную дробь (CachedFraction)
3. Показать разницу:
   - Обычная: getRealValue() → вычисляет каждый раз
   - Кэшированная: 
     * Первый getRealValue() → вычисляет, сохраняет в кэш
     * Второй getRealValue() → берет из кэша
4. Кэшированная дробь:
   - Сбрасывает кэш
### Пример решения задачи  


# Задание 2  
### Задача 1  
Количество мяуканий.  
Необходимо воспользоваться классом Кот и методом принимающим всех мяукающих из задачи 2.5.4. 
Необходимо таким образом передать кота в указанный метод, что бы после окончания его работы 
узнать сколько раз мяукал кот за время его работы. На рисунке показан пример работы. Перед вызовом 
метода создаем кота, отправляем ссылку на кота в метод, после окончания его работы выводим 
количество мяуканий на экран. Кота изменять нельзя.
### Реализация   
1. Meowable - интерфейс с методом meow()
2. Cat - реализует Meowable:
   * Имеет имя и счётчик мяуканий
   * При вызове meow() увеличивает счётчик и выводит "Имя: мяу"
   * Метод getMeowCount() возвращает количество мяуканий
3. Funs - вспомогательный класс:
   * meowsCare(Meowable) - вызывает мяуканье случайное число раз (1-10)
   * Работает с любыми объектами, реализующими Meowable
### Алгоритм решения задачи
1. Пользователь вводит имя кота
2. Программа создает объект Cat
3. Вызывается Funs.meowsCare(cat):
   - Генерирует случайное число мяуканий (1-10)
   - Цикл от 1 до N:
     * cat.meow() → увеличивает счетчик, выводит "Имя: мяу"
     * Пауза 200мс
4. Показать результат: "Кот мяукал N раз"
### Пример решения задачи  

# Задание 3  
### Задача 10  
Оставить в списке только первые вхождения одинаковых элементов. 
### Реализация   
ListProcessor с методом keepFirstOccurrences(List<T>):
   * Использует HashSet для отслеживания уже встреченных элементов
   * Проходит по списку один раз, сохраняя только первые вхождения
   * Сохраняет исходный порядок элементов
### Алгоритм решения задачи
1. Пользователь вводит элементы через пробел
2. Программа создает список из введенных элементов
3. Вызывает ListProcessor.keepFirstOccurrences():
   - Создать пустой результат (List)
   - Создать пустое множество seen (Set)
   - Для каждого элемента в исходном списке:
     * Если элемента нет в seen:  
       ✓ Добавить элемент в результат  
       ✓ Добавить элемент в seen  
     * Иначе: пропустить элемент
4. Вывести: исходный список → результат
### Пример решения задачи  


# Задание 4  
### Задача 10  
В соревнованиях по многоборью (из M видов спорта) участвуют N спортсменов (N< 1000) .На 
вход программе в первой строке подается число спортсменов N, во второй – число видов спорта 
M. В каждой из последующих N строк находится информация в следующем формате: 
<Фамилия><Имя><Баллы>, где <Фамилия> – строка, состоящая не более, чем из 20 символов без пробелов, <Имя> – строка, 
состоящая не более, чем из 12 символов без пробелов, <Баллы> –Mцелых чисел, обозначающие 
количество баллов, набранных спортсменом в каждом из видов многоборья. 
<Фамилия> и <Имя>, <Имя> и <Баллы>, а также отдельные числа в поле <Баллы>разделены 
ровно одним пробелом. 
Программа должна выводить результирующую таблицу, содержащую список спортсменов, 
отсортированный по убыванию суммы баллов, набранные суммы и занятые места. 
### Реализация   
1. Athlete - представляет спортсмена:
   * Фамилия, имя, список баллов
   * Метод вычисления суммы баллов
2. Competition - обрабатывает данные соревнований:
   * Читает входные данные (N спортсменов, M видов спорта)
   * Создает объекты Athlete, вычисляет суммы
   * Сортирует по убыванию суммы баллов
   * Определяет места с учетом одинаковых баллов
### Алгоритм решения задачи
1. Программа читает файл:
   - Строка 1: количество спортсменов (N)
   - Строка 2: количество видов спорта (M)
   - Следующие N строк: данные спортсменов
2. Создать список Athlete:
   - Для каждого спортсмена:
     * Разбить строку на части
     * Вычислить сумму баллов
     * Создать объект Athlete
3. Отсортировать спортсменов по убыванию суммы баллов
4. Рассчитать места:
   - Первый спортсмен → место 1
   - Для каждого следующего спортсмена:
     * Если баллы = предыдущему → такое же место
     * Иначе → место = позиция в списке + 1
5. Вывести таблицу результатов
### Пример решения задачи  

# Задание 5  
### Задача 6  
Файл содержит текст на русском языке. Напечатать в символы, которые встречаются хотя бы 
однажды в словах с чётными номерами (нумерацию вести с 1). 
### Реализация   
TextAnalyzer с методом getCharsFromEvenWords(String):
   * Разбивает текст на слова
   * Проходит по словам, нумеруя с 1
   * Для слов с четными номерами (2, 4, 6...) собирает все символы
   * Возвращает Set<Character> (уникальные символы)
### Алгоритм решения задачи
1. Пользователь вводит текст
2. Программа разбивает текст на слова
3. Создать множество символов (Set<Character>)
4. Для каждого слова (нумерация с 1):
   - Если номер слова четный:
     * Для каждого символа в слове:  
       ✓ Добавить символ в множество
5. Вывести все уникальные символы из множества
### Пример решения задачи  


# Задание 6  
### Задача 1  
Напечатать в обратном порядке элементы непустой очереди L. 
### Реализация   
QueueReverser с методом printQueueReversed(Queue<T>):
   * Проверяет, не пуста ли очередь
   * Создает копию очереди, чтобы не изменять оригинал
   * Перекладывает все элементы из очереди в стек:
     - Берёт элемент из начала очереди
     - Кладёт элемент на вершину стека.
   * Печатает элементы из стека
     - Берет элемент с вершины стека
     - Выводит их на экран
     - Элементы выводятся в обратном порядке (последний стал первым).
### Алгоритм решения задачи
1. Пользователь вводит элементы очереди через пробел
2. Программа создает очередь (Queue)
3. Вызывает QueueReverser.printQueueReversed():
   - Создать копию очереди (чтобы не изменить оригинал)
   - Создать пустой стек (Stack)
   - Пока очередь не пуста:
     * Взять элемент из начала очереди (poll())
     * Положить элемент в стек (push())
   - Пока стек не пуст:
     * Взять элемент с вершины стека (pop())
     * Вывести элемент
4. Показать: исходная очередь → элементы в обратном порядке
### Пример решения задачи  


# Задание 7  
### Задача 1  
Необходимо написать стрим: 
Дан набор объектов типа Point, необходимо взять все Point в разных координатах, убрать с 
одинаковыми X,Y, отсортировать по X, отрицательные Y сделать положительными и собрать это 
все в ломаную (объект типа Polyline).
### Реализация   
1. Point - точка с координатами (x, y)
2. Line - линия между двумя точками
3. Polyline - ломаная линия из набора точек
4. StreamProcessor.processPoints(List<Point>):
   * distinct() - убирает дубликаты точек
   * sorted(Comparator.comparingInt(Point::getX)) - сортирует по X
   * map(p -> new Point(p.getX(), Math.abs(p.getY()))) - делает Y положительными
   * collect(Collectors.collectingAndThen(
                        Collectors.toList(),
                        Polyline::new
                )) - собирает в Polyline
### Алгоритм решения задачи
1. Пользователь выбирает "Обработка точек"
2. Пользователь вводит точки в формате "x y":
   - Пока не введет пустую строкю
3. Вызывает StreamProcessor.processPoints():
   - Удалить дубликаты точек (distinct())
   - Отсортировать по координате X (sorted())
   - Преобразовать: сделать Y положительными (map())
   - Собрать в ломаную линию (collect())
4. Вывести ломаную линию
### Пример решения задачи  

 
### Задача 2   
Дан текстовый файл со строками, содержащими имя человека и его номер в следующей форме: 
Вася:5 
Петя:3 
Аня:5 
Номера людей могут повторяться. У каких-то людей может не быть номера. 
Необходимо написать стрим выполняющую следующее: 
читаются все люди из файла, все имена приводится к нижнему регистру, но с первой буквой в 
верхнем регистре, убираем из перечня всех людей без номеров, а имена оставшихся группируются 
по их номеру: 
[5:[Вася, Аня], 3:[Петя]] 
### Реализация  
StreamProcessor.processPeopleFile(String):
   * Files.lines() - читает файл построчно
   * map(line -> line.split(":")) - разбивает строки
   * filter() - оставляет только строки с именем и номером
   * map() - форматирует имена (первая буква заглавная)
   * collect(Collectors.groupingBy()) - группирует имена по номерам
### Алгоритм решения задачи
1. Пользователь выбирает "Обработка файла"
2. Вызывает StreamProcessor.processPeopleFile():
   - Прочитать все строки файла (Files.lines())
   - Разбить каждую строку по ":" (map(split(":")))
   - Отфильтровать:
     * Только строки с 2 частями
     * Вторая часть (номер) не пустая
   - Преобразовать:
     * Отформатировать имя: первая буква заглавная
     * Преобразовать номер в число
   - Сгруппировать имена по номерам (groupingBy())
3. Вывести результат: номер → список имен
### Пример решения задачи  

